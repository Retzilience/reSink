from __future__ import annotations

import os
import re
import subprocess
from pathlib import Path

APP_NAME = "reSink"
REPO_URL = "https://github.com/Retzilience/reSink"

# I keep this updated (or override via env/build tooling).
VERSION = "0.2"

_HASH_RE = re.compile(r"^[0-9a-f]{7,40}$", re.IGNORECASE)
_TAG_LONG_RE = re.compile(r"^(\d+(?:\.\d+)*)(?:-(\d+)-g([0-9a-f]{7,40}))?$", re.IGNORECASE)


def _with_dirty(ver: str, dirty: bool) -> str:
    if not dirty:
        return ver
    return f"{ver}.dirty" if "+" in ver else f"{ver}+dirty"


def _normalize_git_describe(raw: str) -> str:
    s = (raw or "").strip()
    if not s:
        return str(VERSION).strip() or "0"

    dirty = False
    if s.endswith("-dirty"):
        dirty = True
        s = s[:-6]

    s = s.lstrip("vV")

    m = _TAG_LONG_RE.match(s)
    if m:
        base, ahead, ghash = m.group(1), m.group(2), m.group(3)
        if ahead and ghash and int(ahead) > 0:
            v = f"{base}+r{ahead}.g{ghash}"
        else:
            v = base
        return _with_dirty(v, dirty)

    if _HASH_RE.match(s):
        v = f"{str(VERSION).strip() or '0'}+g{s}"
        return _with_dirty(v, dirty)

    v = str(VERSION).strip() or "0"
    return _with_dirty(v, dirty)


def detect_version() -> str:
    v = (os.environ.get("RESINK_VERSION") or "").strip()
    if v:
        return v

    try:
        import importlib.metadata

        # I try multiple plausible distribution names.
        for name in ("reSink", "resink", "resink-gui"):
            try:
                vv = importlib.metadata.version(name)
                if vv:
                    return str(vv)
            except Exception:
                pass
    except Exception:
        pass

    try:
        root = Path(__file__).resolve().parent
        if (root / ".git").exists() or (root.parent / ".git").exists():
            p = subprocess.run(
                ["git", "describe", "--tags", "--dirty", "--always"],
                cwd=str(root),
                capture_output=True,
                text=True,
            )
            if p.returncode == 0:
                gd = (p.stdout or "").strip()
                if gd:
                    return _normalize_git_describe(gd)
    except Exception:
        pass

    return str(VERSION).strip() or "0"
from __future__ import annotations

import configparser
import os
import platform
import sys
from dataclasses import dataclass
from pathlib import Path

DEFAULT_CONFIG_TEXT = """\
[Patchbay]
selected_app =
custom_path =
info =

[App]
last_exe_path =
"""


def _windows_appdata_dir() -> Path:
    appdata = os.environ.get("APPDATA")
    if appdata:
        return Path(appdata)
    home = Path.home()
    return home / "AppData" / "Roaming"


def _linux_xdg_config_dir() -> Path:
    xdg = os.environ.get("XDG_CONFIG_HOME")
    if xdg:
        return Path(xdg)
    return Path.home() / ".config"


def user_config_dir(app_name: str) -> Path:
    sysname = platform.system().lower()
    if sysname.startswith("windows"):
        return _windows_appdata_dir() / app_name
    if sysname.startswith("linux"):
        return _linux_xdg_config_dir() / app_name
    return Path.home() / ".config" / app_name


def detect_executable_path() -> str:
    """
    I record the path used to launch the app, which is what you want for “where the bin is”.
    For frozen builds, argv[0] should be the executable path; for source runs, it is the script path.
    """
    try:
        p = Path(sys.argv[0]).expanduser()
        if not p.is_absolute():
            p = (Path.cwd() / p).resolve()
        else:
            p = p.resolve()
        return str(p)
    except Exception:
        return ""


@dataclass(frozen=True)
class ConfigStore:
    app_name: str = "reSink"
    filename: str = "resink.cfg"

    @property
    def dir_path(self) -> Path:
        return user_config_dir(self.app_name)

    @property
    def file_path(self) -> Path:
        return self.dir_path / self.filename

    def ensure_exists(self) -> None:
        self.dir_path.mkdir(parents=True, exist_ok=True)
        if not self.file_path.exists():
            self.file_path.write_text(DEFAULT_CONFIG_TEXT, encoding="utf-8")

    def load(self) -> configparser.ConfigParser:
        self.ensure_exists()
        cfg = configparser.ConfigParser()
        cfg.read(self.file_path, encoding="utf-8")

        if not cfg.has_section("Patchbay"):
            cfg.add_section("Patchbay")
        cfg.set("Patchbay", "selected_app", cfg.get("Patchbay", "selected_app", fallback=""))
        cfg.set("Patchbay", "custom_path", cfg.get("Patchbay", "custom_path", fallback=""))
        cfg.set("Patchbay", "info", cfg.get("Patchbay", "info", fallback=""))

        if not cfg.has_section("App"):
            cfg.add_section("App")
        cfg.set("App", "last_exe_path", cfg.get("App", "last_exe_path", fallback=""))

        return cfg

    def save(self, cfg: configparser.ConfigParser) -> None:
        self.ensure_exists()
        with self.file_path.open("w", encoding="utf-8") as f:
            cfg.write(f)

    def record_last_exe_path(self) -> None:
        """
        I write the current executable path into config so future updates can find the installed location.
        """
        cfg = self.load()
        p = detect_executable_path().strip()
        if not p:
            return
        if not cfg.has_section("App"):
            cfg.add_section("App")
        if cfg.get("App", "last_exe_path", fallback="").strip() != p:
            cfg.set("App", "last_exe_path", p)
            self.save(cfg)
from __future__ import annotations

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QAbstractSpinBox,
    QCheckBox,
    QDialog,
    QFormLayout,
    QHBoxLayout,
    QLayout,
    QLineEdit,
    QMessageBox,
    QPushButton,
    QSpinBox,
    QVBoxLayout,
)

import pulsectl

from resink_backend import (
    create_virtual_sink,
    set_default_sink,
    suggest_resink_name,
    wait_for_sink_to_appear,
)


class CreateVirtualSinkDialog(QDialog):
    """
    I create a virtual sink and optionally set it as default.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Create virtual sink")
        self.setModal(True)
        self.setSizeGripEnabled(False)

        outer = QVBoxLayout()
        outer.setContentsMargins(12, 12, 12, 12)
        outer.setSpacing(12)
        outer.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(outer)

        form = QFormLayout()
        form.setLabelAlignment(Qt.AlignRight | Qt.AlignVCenter)
        form.setFormAlignment(Qt.AlignTop)
        form.setHorizontalSpacing(12)
        form.setVerticalSpacing(10)
        outer.addLayout(form)

        try:
            suggested = suggest_resink_name()
        except pulsectl.PulseError:
            suggested = "reSink"

        self.sink_name_input = QLineEdit(suggested)
        self.sink_name_input.setMinimumWidth(360)
        form.addRow("Sink name:", self.sink_name_input)

        self.sample_rate_input = QSpinBox()
        self.sample_rate_input.setRange(16000, 192000)
        self.sample_rate_input.setValue(48000)
        self.sample_rate_input.setMinimumWidth(180)
        self.sample_rate_input.setAlignment(Qt.AlignRight)
        self.sample_rate_input.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.PlusMinus)
        form.addRow("Sample rate (Hz):", self.sample_rate_input)

        self.make_default_checkbox = QCheckBox("Make default")
        form.addRow("", self.make_default_checkbox)

        btns = QHBoxLayout()
        btns.setSpacing(10)

        create_btn = QPushButton("Create")
        create_btn.setObjectName("Primary")
        create_btn.clicked.connect(self._create_clicked)
        btns.addWidget(create_btn)

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btns.addWidget(cancel_btn)

        btns.addStretch(1)
        outer.addLayout(btns)

    def _create_clicked(self) -> None:
        name = self.sink_name_input.text().strip()
        if not name:
            QMessageBox.warning(self, "Invalid name", "Sink name cannot be empty.")
            return

        sr = int(self.sample_rate_input.value())
        make_default = bool(self.make_default_checkbox.isChecked())

        try:
            create_virtual_sink(name=name, sample_rate=sr)
            wait_for_sink_to_appear(name)
        except Exception as e:
            QMessageBox.critical(self, "Create failed", f"Failed to create sink.\n\n{e}")
            return

        if make_default:
            try:
                set_default_sink(name)
            except Exception as e:
                QMessageBox.warning(self, "Default failed", f"Failed to set default sink.\n\n{e}")

        self.accept()
# source/dialogs_patchbay_settings.py
from __future__ import annotations

import shutil

from PySide6.QtWidgets import (
    QButtonGroup,
    QDialog,
    QFileDialog,
    QFormLayout,
    QHBoxLayout,
    QLineEdit,
    QMessageBox,
    QPushButton,
    QRadioButton,
    QVBoxLayout,
)

from config_store import ConfigStore
from patchbay import find_asyphon_launch_argv


class PatchbaySettingsDialog(QDialog):
    """
    I store a patchbay launcher choice.
    """

    def __init__(self, store: ConfigStore, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Patchbay settings")
        self.setMinimumSize(520, 260)

        self.store = store
        self.config = self.store.load()

        # I keep insertion order here because it is also the UI order.
        self.applications: dict[str, tuple[str, str]] = {
            "asyphon": ("aSyphon", ""),  # installed check is config-based, not PATH-based
            "qpwgraph": ("qpwgraph", "qpwgraph"),
            "helvum": ("helvum", "helvum"),
            "patchance": ("patchance", "patchance"),
        }

        layout = QVBoxLayout()
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(10)
        self.setLayout(layout)

        form = QFormLayout()
        layout.addLayout(form)

        self.button_group = QButtonGroup(self)
        self.button_group.setExclusive(True)
        self.radio_buttons: dict[str, QRadioButton] = {}

        for key, (label, exe) in self.applications.items():
            rb = QRadioButton(label)

            if key == "asyphon":
                installed = find_asyphon_launch_argv() is not None
                rb.setEnabled(installed)
                if not installed:
                    rb.setToolTip("aSyphon is not available (no asyphon.cfg with a valid [App] last_exe_path).")
            else:
                installed = shutil.which(exe) is not None
                rb.setEnabled(installed)
                if not installed:
                    rb.setToolTip(f"{label} is not installed.")

            self.radio_buttons[key] = rb
            self.button_group.addButton(rb)
            form.addRow(rb)

        self.custom_radio = QRadioButton("custom")
        self.button_group.addButton(self.custom_radio)
        form.addRow(self.custom_radio)

        self.custom_edit = QLineEdit()
        browse_btn = QPushButton("Browse")
        browse_btn.clicked.connect(self._browse_custom)
        browse = QHBoxLayout()
        browse.setSpacing(8)
        browse.addWidget(self.custom_edit)
        browse.addWidget(browse_btn)
        form.addRow("Custom path:", browse)

        selected_app = (self.config.get("Patchbay", "selected_app", fallback="") or "").strip()
        custom_path = (self.config.get("Patchbay", "custom_path", fallback="") or "").strip()

        done_select = False

        if selected_app in self.radio_buttons:
            rb = self.radio_buttons.get(selected_app)
            if rb is not None and rb.isEnabled():
                rb.setChecked(True)
                done_select = True

        if selected_app == "custom":
            self.custom_radio.setChecked(True)
            self.custom_edit.setText(custom_path)
            done_select = True

        if not done_select:
            for k in self.applications.keys():
                rb = self.radio_buttons.get(k)
                if rb is not None and rb.isEnabled():
                    rb.setChecked(True)
                    done_select = True
                    break

        if not done_select:
            self.custom_radio.setChecked(True)

        self._toggle_custom_edit()
        self.custom_radio.toggled.connect(self._toggle_custom_edit)
        for rb in self.radio_buttons.values():
            rb.toggled.connect(self._toggle_custom_edit)

        btns = QHBoxLayout()
        btns.setSpacing(10)

        save_btn = QPushButton("Save")
        save_btn.setObjectName("Primary")
        save_btn.clicked.connect(self._save)
        btns.addWidget(save_btn)

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btns.addWidget(cancel_btn)

        btns.addStretch(1)
        layout.addLayout(btns)

    def _toggle_custom_edit(self) -> None:
        self.custom_edit.setEnabled(self.custom_radio.isChecked())

    def _browse_custom(self) -> None:
        file_path, _ = QFileDialog.getOpenFileName(self, "Select patchbay executable", "", "All Files (*)")
        if file_path:
            self.custom_edit.setText(file_path)

    def _save(self) -> None:
        selected_app: str | None = None
        for k, rb in self.radio_buttons.items():
            if rb.isChecked():
                selected_app = k
                break
        if self.custom_radio.isChecked():
            selected_app = "custom"

        if not selected_app:
            QMessageBox.warning(self, "No selection", "Select a patchbay application or custom.")
            return

        custom_path = self.custom_edit.text().strip() if selected_app == "custom" else ""
        if selected_app == "custom" and not custom_path:
            QMessageBox.warning(self, "Invalid path", "Custom path cannot be empty.")
            return

        if not self.config.has_section("Patchbay"):
            self.config.add_section("Patchbay")

        self.config.set("Patchbay", "selected_app", selected_app)
        self.config.set("Patchbay", "custom_path", custom_path)

        self.store.save(self.config)
        self.accept()
# source/main.py
from __future__ import annotations

import sys

from PySide6.QtWidgets import QApplication

from theme import apply_dark_theme
from ui_main_window import MainWindow


def main() -> int:
    app = QApplication(sys.argv)
    apply_dark_theme(app)
    w = MainWindow()
    w.show()
    return app.exec()


if __name__ == "__main__":
    raise SystemExit(main())
# source/patchbay.py
from __future__ import annotations

import configparser
import os
import platform
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional

from PySide6.QtWidgets import QMessageBox, QWidget

from config_store import ConfigStore


@dataclass(frozen=True)
class PatchbayChoice:
    kind: str  # "asyphon" | "qpwgraph" | "helvum" | "patchance" | "custom"
    argv: List[str]


def _windows_appdata_dir() -> Path:
    appdata = os.environ.get("APPDATA")
    if appdata:
        return Path(appdata)
    home = Path.home()
    return home / "AppData" / "Roaming"


def _linux_xdg_config_dir() -> Path:
    xdg = os.environ.get("XDG_CONFIG_HOME")
    if xdg:
        return Path(xdg)
    return Path.home() / ".config"


def _candidate_asyphon_cfg_paths() -> List[Path]:
    sysname = platform.system().lower()

    if sysname.startswith("windows"):
        base = _windows_appdata_dir()
    elif sysname.startswith("linux"):
        base = _linux_xdg_config_dir()
    else:
        base = Path.home() / ".config"

    dirs = ("aSyphon", "asyphon", "ASyphon")
    files = ("asyphon.cfg", "aSyphon.cfg")

    out: List[Path] = []
    for d in dirs:
        for fn in files:
            out.append(base / d / fn)
    return out


def _read_asyphon_last_exe_path(cfg_path: Path) -> str:
    try:
        cp = configparser.ConfigParser()
        cp.read(cfg_path, encoding="utf-8")
        return (cp.get("App", "last_exe_path", fallback="") or "").strip()
    except Exception:
        return ""


def _normalize_path(raw: str, *, relative_to: Path) -> Path:
    p = Path(raw).expanduser()
    if not p.is_absolute():
        p = (relative_to / p).resolve()
    else:
        p = p.resolve()
    return p


def find_asyphon_launch_argv() -> Optional[List[str]]:
    """
    I locate aSyphon via its own config (asyphon.cfg) by reading [App] last_exe_path.
    If that path points to a .py file, I launch it with sys.executable.
    """
    for cfg_path in _candidate_asyphon_cfg_paths():
        if not cfg_path.exists():
            continue

        raw = _read_asyphon_last_exe_path(cfg_path)
        if not raw:
            continue

        p = _normalize_path(raw, relative_to=cfg_path.parent)
        if not p.exists():
            continue
        if not p.is_file():
            continue

        if p.suffix.lower() == ".py":
            return [sys.executable, str(p)]
        return [str(p)]

    return None


def resolve_patchbay_choice(store: ConfigStore) -> Optional[PatchbayChoice]:
    cfg = store.load()
    selected_app = (cfg.get("Patchbay", "selected_app", fallback="") or "").strip()
    custom_path = (cfg.get("Patchbay", "custom_path", fallback="") or "").strip()

    if not selected_app:
        return None

    if selected_app == "asyphon":
        argv = find_asyphon_launch_argv()
        if not argv:
            return None
        return PatchbayChoice(kind="asyphon", argv=argv)

    if selected_app in ("qpwgraph", "helvum", "patchance"):
        return PatchbayChoice(kind=selected_app, argv=[selected_app])

    if selected_app == "custom":
        if not custom_path:
            return None

        cmd = custom_path.strip()
        p = Path(cmd).expanduser()
        if p.exists() and p.is_file():
            return PatchbayChoice(kind="custom", argv=[str(p.resolve())])

        # I keep the old behavior for power users who typed a command string.
        return PatchbayChoice(kind="custom", argv=cmd.split())

    return None


def launch_patchbay(choice: PatchbayChoice, parent: QWidget) -> None:
    if not choice.argv or not (choice.argv[0] or "").strip():
        QMessageBox.critical(parent, "Patchbay", "Invalid patchbay command.")
        return

    try:
        subprocess.Popen(list(choice.argv), close_fds=True)
    except FileNotFoundError:
        QMessageBox.critical(parent, "Patchbay", f"Command not found:\n\n{choice.argv[0]}")
    except Exception as e:
        QMessageBox.critical(parent, "Patchbay", f"Failed to launch patchbay:\n\n{e}")
# source/rehelp.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, Optional, Sequence

import platform
import sys

from PySide6.QtCore import QUrl, Qt
from PySide6.QtGui import QGuiApplication
from PySide6.QtWidgets import (
    QDialog,
    QHBoxLayout,
    QLabel,
    QPushButton,
    QTextBrowser,
    QVBoxLayout,
    QWidget,
)

from reupdater import ReProject, UpdateClient, UpdateResult, open_url_external

DEFAULT_CSS = """
body { font-family: sans-serif; line-height: 1.35; margin: 0; padding: 0; background: transparent; color: #e6e6e6; }
.wrap { padding: 10px 12px; }
h1 { font-size: 16px; margin: 0 0 10px 0; }
h2 { font-size: 13px; margin: 16px 0 6px 0; color: #cfd3da; }
p { margin: 6px 0; }
ul { margin: 6px 0 6px 18px; padding: 0; }
li { margin: 4px 0; }
code { font-family: monospace; background: #202025; padding: 1px 4px; border: 1px solid #3a3a42; border-radius: 3px; }
.kv { font-family: monospace; white-space: pre-wrap; background: #202025; border: 1px solid #3a3a42; border-radius: 4px; padding: 8px; margin: 8px 0; }
.muted { color: #b0b0b0; }
a { text-decoration: none; color: #8fb3ff; }
"""


@dataclass(frozen=True)
class HelpAction:
    label: str
    kind: str  # "url" | "callback"
    url: str = ""
    callback: Optional[Callable[[], None]] = None
    tooltip: str = ""


def diagnostics_text(project: ReProject) -> str:
    qt = "Qt"
    try:
        import PySide6  # noqa: F401
        qt = "Qt/PySide6"
    except Exception:
        pass

    return (
        f"App: {project.name or project.repo}\n"
        f"Version: {project.version}\n"
        f"Repo: {project.repo_url()}\n"
        f"Descriptor: {project.descriptor_url()}\n"
        f"Platform: {platform.platform()}\n"
        f"Python: {sys.version.splitlines()[0]}\n"
        f"UI: {qt}\n"
    )


def wrap_help_html(title: str, body_html: str, *, css: str = DEFAULT_CSS) -> str:
    t = title or "Help / About"
    b = body_html or ""
    return f"""<html>
<head><style>{css}</style></head>
<body>
  <div class="wrap">
    <h1>{t}</h1>
    {b}
  </div>
</body>
</html>"""


class HelpDialog(QDialog):
    def __init__(
        self,
        parent: Optional[QWidget],
        project: ReProject,
        *,
        html: str,
        updater: Optional[UpdateClient] = None,
        extra_actions: Sequence[HelpAction] = (),
        title: Optional[str] = None,
    ) -> None:
        super().__init__(parent)
        self.setWindowTitle(title or f"{project.name or project.repo} — Help / About")
        self.setMinimumSize(860, 560)
        self.resize(900, 620)

        self._project = project
        self._updater = updater or UpdateClient(self, project)
        self._updater.checked.connect(self._on_update_result)

        outer = QVBoxLayout(self)
        outer.setContentsMargins(12, 12, 12, 12)
        outer.setSpacing(10)

        header = QHBoxLayout()
        header.setSpacing(10)

        name_lbl = QLabel(project.name or project.repo)
        name_lbl.setStyleSheet("font-size: 16px; font-weight: 700;")
        ver_lbl = QLabel(f"v{project.version}")
        ver_lbl.setStyleSheet("color: #b0b0b0;")

        header.addWidget(name_lbl)
        header.addWidget(ver_lbl)
        header.addStretch(1)

        self._status = QLabel("")
        self._status.setStyleSheet("color: #b0b0b0;")
        header.addWidget(self._status)

        outer.addLayout(header)

        self._text = QTextBrowser()
        self._text.setOpenExternalLinks(False)
        self._text.setOpenLinks(False)
        self._text.anchorClicked.connect(self._on_anchor_clicked)
        self._text.setHtml(html)
        outer.addWidget(self._text, 1)

        btns = QHBoxLayout()
        btns.setContentsMargins(0, 0, 0, 0)
        btns.setSpacing(8)

        self._btn_updates = QPushButton("Check updates")
        self._btn_updates.clicked.connect(self._check_updates)

        self._btn_releases = QPushButton("Releases")
        self._btn_releases.clicked.connect(lambda: open_url_external(project.releases_url()))

        self._btn_issues = QPushButton("Report bug")
        self._btn_issues.clicked.connect(lambda: open_url_external(project.issues_url()))

        self._btn_repo = QPushButton("Repository")
        self._btn_repo.clicked.connect(lambda: open_url_external(project.repo_url()))

        self._btn_copy = QPushButton("Copy diagnostics")
        self._btn_copy.clicked.connect(self._copy_diagnostics)

        btns.addWidget(self._btn_updates)
        btns.addSpacing(6)
        btns.addWidget(self._btn_releases)
        btns.addWidget(self._btn_issues)
        btns.addWidget(self._btn_repo)
        btns.addSpacing(6)
        btns.addWidget(self._btn_copy)

        for a in extra_actions:
            b = QPushButton(a.label)
            if a.tooltip:
                b.setToolTip(a.tooltip)
            if a.kind == "url":
                u = a.url
                b.clicked.connect(lambda _=False, uu=u: open_url_external(uu))
            else:
                cb = a.callback
                b.clicked.connect(lambda _=False, c=cb: c() if c else None)
            btns.addWidget(b)

        btns.addStretch(1)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btns.addWidget(close_btn)

        outer.addLayout(btns)

    def set_html(self, html: str) -> None:
        self._text.setHtml(html)

    def _on_anchor_clicked(self, url: QUrl) -> None:
        try:
            open_url_external(url.toString())
        except Exception:
            pass

    def _copy_diagnostics(self) -> None:
        try:
            QGuiApplication.clipboard().setText(diagnostics_text(self._project))
            self._status.setText("Diagnostics copied.")
        except Exception:
            self._status.setText("Failed to copy diagnostics.")

    def _check_updates(self) -> None:
        self._status.setText("Checking for updates…")
        self._updater.check_now(ignore_skip=True, show_dialog=True)

    def _on_update_result(self, res: UpdateResult) -> None:
        if res.status == "no_update":
            self._status.setText("No updates available.")
        elif res.status == "update_available":
            self._status.setText(f"Update available: {res.latest.version if res.latest else ''}".strip())
        elif res.status == "deprecated":
            self._status.setText("Update required (deprecated).")
        elif res.status == "no_entry":
            self._status.setText("No update entry for this OS.")
        else:
            self._status.setText("Update check failed.")
# source/resink_backend.py
from __future__ import annotations

import os
import subprocess
import time
from dataclasses import dataclass
from typing import List, Optional

import pulsectl


@dataclass(frozen=True)
class SinkInfo:
    name: str
    description: str
    is_virtual: bool
    is_default: bool


def _run(cmd: List[str]) -> subprocess.CompletedProcess[str]:
    return subprocess.run(list(cmd), capture_output=True, text=True)


def is_virtual_sink(sink: pulsectl.PulseSinkInfo) -> bool:
    """
    I treat the sink as virtual if it looks like a null sink or it lacks typical physical identifiers.
    """
    factory = (sink.proplist.get("factory.name", "") or "").lower()
    if "null-audio-sink" in factory:
        return True
    if "module-null-sink" in factory:
        return True

    mc = (sink.proplist.get("media.class", "") or "").lower()
    if mc == "audio/sink":
        physical_keys = ["alsa.card", "device.bus", "device.serial"]
        if not any(key in sink.proplist for key in physical_keys):
            return True
    return False


def suggest_resink_name() -> str:
    """
    I suggest the next free name in the sequence reSink, reSink-2, reSink-3, ...
    """
    base_name = "reSink"
    with pulsectl.Pulse("resink-manager") as pulse:
        sinks = pulse.sink_list()
        existing_names = {s.name for s in sinks}

    if base_name not in existing_names:
        return base_name

    i = 2
    while True:
        candidate = f"{base_name}-{i}"
        if candidate not in existing_names:
            return candidate
        i += 1


def get_sink_node_id_by_name(node_name: str) -> Optional[str]:
    """
    I resolve PipeWire node id by node.name using pw-cli list-objects output.
    """
    try:
        p = _run(["pw-cli", "list-objects"])
        if p.returncode != 0:
            return None

        lines = (p.stdout or "").splitlines()
        for i, line in enumerate(lines):
            if f'node.name = "{node_name}"' not in line:
                continue

            for prev in reversed(lines[:i]):
                s = prev.strip()
                if s.startswith("id"):
                    # Example: "id 56,"
                    parts = s.replace(",", " ").split()
                    if len(parts) >= 2 and parts[1].isdigit():
                        return parts[1]
                    return None

    except FileNotFoundError:
        return None

    return None


def set_default_sink(node_name: str) -> None:
    """
    I set the default sink via wpctl set-default <node-id>.
    """
    sink_id = get_sink_node_id_by_name(node_name)
    if not sink_id:
        raise RuntimeError(f"Sink '{node_name}' not found (cannot set default).")

    try:
        p = _run(["wpctl", "set-default", sink_id])
    except FileNotFoundError as e:
        raise RuntimeError("wpctl not found in PATH.") from e

    if p.returncode != 0:
        msg = (p.stderr or p.stdout).strip()
        raise RuntimeError(f"Failed to set default sink: {msg}")


def create_virtual_sink(name: str, sample_rate: int) -> None:
    """
    I create a virtual sink via pw-cli create-node adapter {...}.
    """
    safe_name = name.replace('"', r"\"")
    props = (
        "{\n"
        "    factory.name=support.null-audio-sink\n"
        f'    node.name="{safe_name}"\n'
        "    media.class=Audio/Sink\n"
        "    object.linger=true\n"
        "    audio.position=[FL FR]\n"
        f"    audio.sample_rate={int(sample_rate)}\n"
        "}\n"
    )

    try:
        p = _run(["pw-cli", "create-node", "adapter", props])
    except FileNotFoundError as e:
        raise RuntimeError("pw-cli not found in PATH.") from e

    if p.returncode != 0:
        msg = (p.stderr or p.stdout).strip()
        raise RuntimeError(msg or "pw-cli create-node failed")


def wait_for_sink_to_appear(name: str, tries: int = 15, delay_s: float = 0.12) -> None:
    with pulsectl.Pulse("resink-manager") as pulse:
        for _ in range(max(1, tries)):
            sinks = pulse.sink_list()
            if any(s.name == name for s in sinks):
                return
            time.sleep(max(0.0, delay_s))
    raise RuntimeError(f"Sink '{name}' did not appear after creation.")


def destroy_sink_by_name(node_name: str) -> None:
    """
    I destroy a sink by node.name by resolving its node id and calling pw-cli destroy <id>.
    """
    sink_id = get_sink_node_id_by_name(node_name)
    if not sink_id:
        raise RuntimeError(f"Sink '{node_name}' not found (cannot destroy).")

    try:
        p = _run(["pw-cli", "destroy", sink_id])
    except FileNotFoundError as e:
        raise RuntimeError("pw-cli not found in PATH.") from e

    if p.returncode != 0:
        msg = (p.stderr or p.stdout).strip()
        raise RuntimeError(msg or f"Failed to destroy sink '{node_name}'.")


class ReSinkBackend:
    def __init__(self, pulse_client_name: str = "resink-gui") -> None:
        self._pulse_client_name = pulse_client_name

    def server_label(self) -> str:
        return "PipeWire (via pipewire-pulse)"

    def list_sinks(self) -> List[SinkInfo]:
        with pulsectl.Pulse(self._pulse_client_name) as pulse:
            server = pulse.server_info()
            default_name = (server.default_sink_name or "").strip()

            out: List[SinkInfo] = []
            for s in pulse.sink_list():
                v = is_virtual_sink(s)
                out.append(
                    SinkInfo(
                        name=s.name,
                        description=s.description or s.name,
                        is_virtual=v,
                        is_default=(s.name == default_name),
                    )
                )
            out.sort(key=lambda x: (not x.is_virtual, x.description.lower(), x.name.lower()))
            return out

    def can_spawn_patchbay(self) -> bool:
        return True

    def env_hint(self) -> str:
        return (os.environ.get("PIPEWIRE_REMOTE") or "").strip()
# source/reupdater.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, Optional, Tuple

import os
import re
import subprocess
import sys
import time
import urllib.parse
import webbrowser

from PySide6.QtCore import QObject, QTimer, QUrl, Qt, Signal, QSettings
from PySide6.QtNetwork import QNetworkAccessManager, QNetworkReply, QNetworkRequest
from PySide6.QtWidgets import QApplication, QCheckBox, QMessageBox, QWidget


@dataclass(frozen=True)
class ReProject:
    owner: str
    repo: str
    version: str
    name: Optional[str] = None

    branch: str = "main"
    descriptor_path: str = "version.upd"

    settings_org: Optional[str] = None
    settings_app: Optional[str] = None

    def repo_url(self) -> str:
        return f"https://github.com/{self.owner}/{self.repo}"

    def releases_url(self) -> str:
        return f"{self.repo_url()}/releases/latest"

    def issues_url(self) -> str:
        return f"{self.repo_url()}/issues"

    def descriptor_url(self) -> str:
        return f"{self.repo_url()}/raw/refs/heads/{self.branch}/{self.descriptor_path}"

    def settings(self) -> QSettings:
        org = (self.settings_org or self.owner or "reupdater").strip()
        app = (self.settings_app or self.repo or "app").strip()
        return QSettings(org, app)


@dataclass(frozen=True)
class UpdateEntry:
    version: str
    os_tag: str
    flags: Tuple[str, ...]
    download: str


@dataclass(frozen=True)
class UpdateResult:
    status: str
    os_tag: str
    current_version: str
    latest: Optional[UpdateEntry]
    download_url: str
    message: str = ""


def detect_os_tag() -> str:
    sp = (sys.platform or "").lower()
    if sp.startswith("win"):
        return "windows"
    if sp.startswith("linux"):
        return "linux"
    if sp == "darwin":
        return "macos"
    return ""


def normalize_os_tag(tag: str) -> str:
    t = (tag or "").strip().lower()
    if t in ("darwin", "mac"):
        return "macos"
    return t


def _version_key(v: str) -> Tuple[int, ...]:
    s = (v or "").strip()
    if s.startswith(("v", "V")):
        s = s[1:]
    parts = [p for p in re.split(r"[.\-_+]", s) if p.strip() != ""]
    out = []
    for p in parts:
        m = re.match(r"^\d+$", p.strip())
        out.append(int(p) if m else 0)
    if not out:
        nums = re.findall(r"\d+", s)
        out = [int(x) for x in nums] if nums else [0]
    return tuple(out)


def compare_versions(a: str, b: str) -> int:
    ta = _version_key(a)
    tb = _version_key(b)
    n = max(len(ta), len(tb))
    ta = ta + (0,) * (n - len(ta))
    tb = tb + (0,) * (n - len(tb))
    return -1 if ta < tb else (1 if ta > tb else 0)


def parse_descriptor(text: str, *, os_tag: str, current_version: str) -> Tuple[Optional[UpdateEntry], Optional[UpdateEntry]]:
    latest: Optional[UpdateEntry] = None
    current: Optional[UpdateEntry] = None

    want = normalize_os_tag(os_tag)
    cur = (current_version or "").strip()

    for raw in (text or "").splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if "#" in line:
            line = line.split("#", 1)[0].strip()
            if not line:
                continue

        parts = [p.strip() for p in line.split("|")]
        if len(parts) < 3:
            continue

        ver = parts[0]
        os_name = normalize_os_tag(parts[1])
        if not ver or os_name != want:
            continue

        if len(parts) == 3:
            flags: Tuple[str, ...] = ()
            dl = parts[2]
        else:
            flags = tuple(f.strip().lower() for f in re.split(r"[,\s]+", parts[2]) if f.strip())
            dl = parts[3] if len(parts) >= 4 else ""

        e = UpdateEntry(version=ver.strip(), os_tag=os_name, flags=flags, download=(dl or "").strip())

        if latest is None or compare_versions(e.version, latest.version) > 0:
            latest = e

        if compare_versions(e.version, cur) == 0:
            current = e

    return latest, current


def build_download_url(project: ReProject, entry: UpdateEntry) -> str:
    s = (entry.download or "").strip()
    if not s:
        return ""

    if re.match(r"^https?://", s, re.IGNORECASE):
        return s

    spec = s.lstrip("/")
    if "/" in spec:
        tag, asset = spec.split("/", 1)
        tag = tag.strip() or entry.version
        asset = asset.strip()
    else:
        tag, asset = entry.version, spec.strip()

    if not asset:
        return ""

    tag_q = urllib.parse.quote(tag, safe="")
    asset_q = urllib.parse.quote(asset, safe="")
    return f"{project.repo_url()}/releases/download/{tag_q}/{asset_q}"


def _clean_env_for_external_launch() -> dict[str, str]:
    env = dict(os.environ)
    for k in (
        "QT_QPA_PLATFORMTHEME",
        "QT_QPA_PLATFORM",
        "QT_PLUGIN_PATH",
        "QT_DEBUG_PLUGINS",
        "QT_LOGGING_RULES",
        "QML2_IMPORT_PATH",
        "QML_IMPORT_PATH",
    ):
        env.pop(k, None)
    return env


def open_url_external(url: str) -> None:
    u = (url or "").strip()
    if not u:
        return

    env = _clean_env_for_external_launch()

    if sys.platform.startswith("linux"):
        for cmd in (["xdg-open", u], ["gio", "open", u]):
            try:
                subprocess.Popen(cmd, env=env)
                return
            except FileNotFoundError:
                continue
            except Exception:
                continue
        try:
            webbrowser.open(u)
        except Exception:
            pass
        return

    if sys.platform.startswith("win"):
        try:
            os.startfile(u)  # type: ignore[attr-defined]
            return
        except Exception:
            pass
        try:
            subprocess.Popen(["cmd", "/c", "start", "", u], env=env, shell=False)
            return
        except Exception:
            pass
        try:
            webbrowser.open(u)
        except Exception:
            pass
        return

    if sys.platform == "darwin":
        try:
            subprocess.Popen(["open", u], env=env)
            return
        except Exception:
            pass
        try:
            webbrowser.open(u)
        except Exception:
            pass
        return

    try:
        webbrowser.open(u)
    except Exception:
        pass


def get_skip_version(project: ReProject) -> str:
    try:
        s = project.settings()
        s.beginGroup("reupdater")
        v = str(s.value("skip_version", "") or "")
        s.endGroup()
        return v.strip()
    except Exception:
        return ""


def set_skip_version(project: ReProject, version: Optional[str]) -> None:
    try:
        s = project.settings()
        s.beginGroup("reupdater")
        s.setValue("skip_version", (version or "").strip())
        s.endGroup()
    except Exception:
        pass


def record_last_check(project: ReProject) -> None:
    try:
        s = project.settings()
        s.beginGroup("reupdater")
        s.setValue("last_check_unix", int(time.time()))
        s.endGroup()
    except Exception:
        pass


class UpdateClient(QObject):
    checked = Signal(object)

    def __init__(
        self,
        parent: QWidget,
        project: ReProject,
        *,
        os_tag: Optional[str] = None,
        descriptor_url: Optional[str] = None,
        get_skip: Optional[Callable[[], str]] = None,
        set_skip: Optional[Callable[[Optional[str]], None]] = None,
        record_check: Optional[Callable[[], None]] = None,
        http_timeout_ms: int = 8000,
    ) -> None:
        super().__init__(parent)

        self._parent = parent
        self._project = project
        self._os_tag = normalize_os_tag(os_tag or detect_os_tag())
        self._descriptor_url = (descriptor_url or project.descriptor_url()).strip()

        self._get_skip = get_skip or (lambda: get_skip_version(project))
        self._set_skip = set_skip or (lambda v: set_skip_version(project, v))
        self._record_check = record_check or (lambda: record_last_check(project))

        self._timeout_ms = int(max(1000, http_timeout_ms))

        self._mgr = QNetworkAccessManager(self)
        self._mgr.finished.connect(self._on_reply)

        self._in_flight = False
        self._ignore_skip = False
        self._show_dialog = False
        self._cb: Optional[Callable[[UpdateResult], None]] = None

    def check_startup(self) -> None:
        self.check_now(ignore_skip=False, show_dialog=True, callback=None)

    def check_now(
        self,
        *,
        ignore_skip: bool = False,
        show_dialog: bool = True,
        callback: Optional[Callable[[UpdateResult], None]] = None,
    ) -> None:
        if not self._os_tag or not self._descriptor_url:
            res = UpdateResult(
                status="error",
                os_tag=self._os_tag,
                current_version=str(self._project.version),
                latest=None,
                download_url="",
                message="Missing os_tag or descriptor_url.",
            )
            self._emit(res, callback)
            return

        if self._in_flight:
            res = UpdateResult(
                status="error",
                os_tag=self._os_tag,
                current_version=str(self._project.version),
                latest=None,
                download_url="",
                message="Update check already running.",
            )
            self._emit(res, callback)
            return

        self._in_flight = True
        self._ignore_skip = bool(ignore_skip)
        self._show_dialog = bool(show_dialog)
        self._cb = callback

        req = QNetworkRequest(QUrl(self._descriptor_url))
        try:
            req.setTransferTimeout(self._timeout_ms)
        except Exception:
            pass

        reply = self._mgr.get(req)

        timer = QTimer(self)
        timer.setSingleShot(True)

        def on_timeout() -> None:
            try:
                if reply.isRunning():
                    reply.abort()
            except Exception:
                pass

        def cleanup() -> None:
            try:
                timer.stop()
                timer.deleteLater()
            except Exception:
                pass

        timer.timeout.connect(on_timeout)
        reply.finished.connect(cleanup)
        timer.start(self._timeout_ms)

    def _on_reply(self, reply: QNetworkReply) -> None:
        try:
            try:
                self._record_check()
            except Exception:
                pass

            if reply.error() != QNetworkReply.NetworkError.NoError:
                res = UpdateResult(
                    status="error",
                    os_tag=self._os_tag,
                    current_version=str(self._project.version),
                    latest=None,
                    download_url="",
                    message=reply.errorString(),
                )
                self._finish(res)
                return

            data = reply.readAll()
            try:
                text = bytes(data).decode("utf-8", errors="replace")
            except Exception:
                text = ""

            latest, current = parse_descriptor(text, os_tag=self._os_tag, current_version=str(self._project.version))
            if latest is None:
                res = UpdateResult(
                    status="no_entry",
                    os_tag=self._os_tag,
                    current_version=str(self._project.version),
                    latest=None,
                    download_url="",
                    message="No entry for this OS in descriptor.",
                )
                self._finish(res)
                return

            dl_url = build_download_url(self._project, latest)

            cur_deprecated = bool(current and any(f == "deprecated" for f in current.flags))
            if cur_deprecated:
                res = UpdateResult(
                    status="deprecated",
                    os_tag=self._os_tag,
                    current_version=str(self._project.version),
                    latest=latest,
                    download_url=dl_url,
                    message="Current version is deprecated.",
                )
                if self._show_dialog:
                    self._show_mandatory_dialog(res)
                self._finish(res)
                return

            if compare_versions(latest.version, str(self._project.version)) <= 0:
                res = UpdateResult(
                    status="no_update",
                    os_tag=self._os_tag,
                    current_version=str(self._project.version),
                    latest=latest,
                    download_url=dl_url,
                )
                self._finish(res)
                return

            if not self._ignore_skip:
                try:
                    skip = (self._get_skip() or "").strip()
                except Exception:
                    skip = ""
                if skip and skip == latest.version.strip():
                    res = UpdateResult(
                        status="no_update",
                        os_tag=self._os_tag,
                        current_version=str(self._project.version),
                        latest=latest,
                        download_url=dl_url,
                        message="Update is snoozed.",
                    )
                    self._finish(res)
                    return

            res = UpdateResult(
                status="update_available",
                os_tag=self._os_tag,
                current_version=str(self._project.version),
                latest=latest,
                download_url=dl_url,
            )
            if self._show_dialog:
                self._show_optional_dialog(res)
            self._finish(res)

        finally:
            self._in_flight = False
            try:
                reply.deleteLater()
            except Exception:
                pass

    def _emit(self, res: UpdateResult, cb: Optional[Callable[[UpdateResult], None]]) -> None:
        self.checked.emit(res)
        if cb is not None:
            try:
                cb(res)
            except Exception:
                pass

    def _finish(self, res: UpdateResult) -> None:
        cb = self._cb
        self._cb = None
        self._emit(res, cb)

    def _effective_parent(self) -> QWidget:
        w = QApplication.activeWindow()
        return w if w is not None else self._parent

    def _prepare_box(self, box: QMessageBox) -> None:
        box.setWindowModality(Qt.ApplicationModal)
        try:
            box.raise_()
            box.activateWindow()
        except Exception:
            pass

    def _show_optional_dialog(self, res: UpdateResult) -> None:
        latest = res.latest
        if latest is None:
            return

        app_name = self._project.name or self._project.repo
        box = QMessageBox(self._effective_parent())
        box.setIcon(QMessageBox.Information)
        box.setWindowTitle(f"{app_name} update available")
        box.setText(
            f"A new version is available: {latest.version}\n"
            f"Current: {self._project.version}   OS: {res.os_tag}"
        )

        snooze = QCheckBox("Do not remind me again for this version", box)
        box.setCheckBox(snooze)

        download_btn = box.addButton("Download", QMessageBox.AcceptRole)
        releases_btn = box.addButton("Releases", QMessageBox.NoRole)
        later_btn = box.addButton("Later", QMessageBox.RejectRole)
        box.setDefaultButton(download_btn)

        self._prepare_box(box)
        box.exec()

        if snooze.isChecked():
            try:
                self._set_skip(latest.version.strip())
            except Exception:
                pass

        clicked = box.clickedButton()
        if clicked is releases_btn:
            open_url_external(self._project.releases_url())
        elif clicked is download_btn:
            u = (res.download_url or "").strip() or self._project.releases_url()
            open_url_external(u)
        elif clicked is later_btn:
            return

    def _show_mandatory_dialog(self, res: UpdateResult) -> None:
        latest = res.latest
        app_name = self._project.name or self._project.repo
        latest_ver = (latest.version if latest else "").strip() or str(self._project.version)

        box = QMessageBox(self._effective_parent())
        box.setIcon(QMessageBox.Warning)
        box.setWindowTitle("Update required")
        box.setText(
            f"This version ({self._project.version}) has been marked as deprecated.\n"
            f"You must update to {latest_ver} to continue using {app_name}."
        )

        download_btn = box.addButton("Download", QMessageBox.AcceptRole)
        releases_btn = box.addButton("Releases", QMessageBox.NoRole)
        quit_btn = box.addButton("Quit", QMessageBox.RejectRole)
        box.setDefaultButton(download_btn)

        self._prepare_box(box)
        box.exec()

        clicked = box.clickedButton()
        if clicked is releases_btn:
            open_url_external(self._project.releases_url())
        elif clicked is download_btn:
            u = (res.download_url or "").strip() or self._project.releases_url()
            open_url_external(u)

        try:
            self._parent.close()
        except Exception:
            pass


def project_from_repo(
    repo_url: str,
    *,
    version: str,
    name: Optional[str] = None,
    branch: str = "main",
    descriptor_path: str = "version.upd",
    settings_org: Optional[str] = None,
    settings_app: Optional[str] = None,
) -> ReProject:
    u = (repo_url or "").strip()
    m = re.match(r"^https?://github\.com/([^/]+)/([^/]+)", u, re.IGNORECASE)
    if not m:
        raise ValueError(f"Unrecognized GitHub repo URL: {repo_url!r}")
    owner, repo = m.group(1), m.group(2)
    return ReProject(
        owner=owner,
        repo=repo,
        version=str(version).strip(),
        name=name,
        branch=branch,
        descriptor_path=descriptor_path,
        settings_org=settings_org,
        settings_app=settings_app,
    )
from __future__ import annotations

from PySide6.QtGui import QColor, QPalette
from PySide6.QtWidgets import QApplication


def apply_dark_theme(app: QApplication) -> None:
    app.setStyle("Fusion")

    pal = QPalette()
    pal.setColor(QPalette.Window, QColor(20, 20, 22))
    pal.setColor(QPalette.WindowText, QColor(230, 230, 230))
    pal.setColor(QPalette.Base, QColor(14, 14, 16))
    pal.setColor(QPalette.AlternateBase, QColor(26, 26, 28))
    pal.setColor(QPalette.Text, QColor(230, 230, 230))
    pal.setColor(QPalette.Button, QColor(34, 34, 38))
    pal.setColor(QPalette.ButtonText, QColor(230, 230, 230))
    pal.setColor(QPalette.Highlight, QColor(80, 110, 170))
    pal.setColor(QPalette.HighlightedText, QColor(255, 255, 255))
    pal.setColor(QPalette.Disabled, QPalette.Text, QColor(140, 140, 140))
    pal.setColor(QPalette.Disabled, QPalette.ButtonText, QColor(140, 140, 140))
    pal.setColor(QPalette.Disabled, QPalette.WindowText, QColor(140, 140, 140))
    app.setPalette(pal)

    app.setStyleSheet(
        """
        QMainWindow { background: #141416; }

        QLabel#Title {
            font-size: 16px;
            font-weight: 700;
        }

        QLabel#Subtle {
            color: #aeb3bc;
        }

        QFrame#Panel {
            background: #1b1b1f;
            border: 1px solid #2a2a30;
            border-radius: 10px;
        }

        QWidget#RowCard {
            background: #1f1f24;
            border: 1px solid #2a2a30;
            border-radius: 10px;
        }

        QWidget#RowCard[kind="virtual"] {
            border: 1px solid #3b4f7a;
        }

        QWidget#RowCard[kind="physical"] {
            background: #1c1c20;
            border: 1px solid #2a2a30;
        }

        QWidget#RowCard[selected="true"] {
            background: #202533;
            border: 1px solid #506eaa;
        }

        QWidget#RowCard[default="true"] QLabel#SinkTitle {
            color: #d6e2ff;
        }

        QLabel#SinkTitle {
            font-size: 13px;
            font-weight: 700;
        }

        QLabel#SinkName {
            color: #aeb3bc;
            font-size: 11px;
        }

        QLabel#KindPill {
            padding: 3px 10px;
            border-radius: 10px;
            font-weight: 700;
            letter-spacing: 0.5px;
            font-size: 10px;
        }

        QLabel#KindPill[kind="virtual"] {
            background: #23314a;
            border: 1px solid #3b4f7a;
            color: #d6e2ff;
        }

        QLabel#KindPill[kind="physical"] {
            background: #2a2a30;
            border: 1px solid #3a3a42;
            color: #d6d6d6;
        }

        QLabel#SelectBar {
            padding: 6px 10px;
            border-radius: 9px;
            font-weight: 700;
        }

        QLabel#SelectBar[sel="false"] {
            background: #2a2a30;
            border: 1px solid #3a3a42;
            color: #d6d6d6;
        }

        /* I use an amber/yellow selected state (your “pending” palette), but the text is still “Selected”. */
        QLabel#SelectBar[sel="true"] {
            background: #3a3424;
            border: 1px solid #7a6231;
            color: #f3e6c8;
        }

        QLineEdit, QSpinBox, QTextEdit {
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid #2a2a30;
            background: #121216;
        }

        QPushButton {
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid #2a2a30;
            background: #232329;
        }
        QPushButton:hover { background: #2a2a33; }

        QPushButton:disabled {
            color: #7c7c85;
            background: #1b1b1f;
            border: 1px solid #2a2a30;
        }

        /* I only show “Primary” styling while enabled. */
        QPushButton#Primary:enabled {
            background: #2c3a5a;
            border: 1px solid #3b4f7a;
        }
        QPushButton#Primary:enabled:hover { background: #34456c; }

        /* I only show “Danger” styling while enabled. */
        QPushButton#Danger:enabled {
            background: #3a2424;
            border: 1px solid #7a3131;
        }
        QPushButton#Danger:enabled:hover { background: #442b2b; }

        QPushButton#Icon {
            padding: 0px;
            border-radius: 10px;
            border: 1px solid #2a2a30;
            background: #232329;
        }
        QPushButton#Icon:hover { background: #2a2a33; }
        """
    )
# source/ui_help_content.py
from __future__ import annotations

from rehelp import wrap_help_html


def help_html(app_name: str) -> str:
    return wrap_help_html(
        f"{app_name} — Help / About",
        """
        <p class="muted">
          reSink manages PipeWire/Pulse sinks with a focus on virtual (null) sinks.
          I can create and destroy virtual sinks, set a sink as the default output, and
          launch a patchbay tool (qpwgraph/Helvum/Patchance/custom).
        </p>

        <h2>What reSink is</h2>
        <ul>
          <li><b>Virtual sink manager</b>: create and tear down null sinks.</li>
          <li><b>Default sink helper</b>: set the system default output sink.</li>
          <li><b>Patchbay launcher</b>: open your chosen graph UI from one place.</li>
        </ul>

        <h2>How selection works</h2>
        <ul>
          <li>Only <b>virtual sinks</b> can be selected for destructive operations.</li>
          <li><b>Destroy selected</b> removes the selected virtual sinks.</li>
          <li><b>Make default</b> requires exactly one selection.</li>
        </ul>

        <h2>Patchbay</h2>
        <ul>
          <li>Configure a patchbay app in <b>Patchbay settings</b>.</li>
          <li>reSink can launch qpwgraph/Helvum/Patchance or a custom executable.</li>
        </ul>

        <h2>Troubleshooting</h2>
        <ul>
          <li><b>Can’t create/destroy</b>: ensure <code>pw-cli</code> exists in PATH.</li>
          <li><b>Can’t set default</b>: ensure <code>wpctl</code> exists in PATH.</li>
          <li><b>No sinks shown</b>: ensure <code>pipewire-pulse</code> is running.</li>
        </ul>

        <h2>Support</h2>
        <p class="muted">
          Use the buttons below to open the repository, releases, or file a bug report.
          Include “Copy diagnostics” output when reporting issues.
        </p>
        """,
    )
# source/ui_main_window.py
from __future__ import annotations

from typing import List

from PySide6.QtCore import Qt
from PySide6.QtGui import QFont, QIcon
from PySide6.QtWidgets import (
    QFrame,
    QHBoxLayout,
    QLabel,
    QMainWindow,
    QMessageBox,
    QPushButton,
    QScrollArea,
    QSizePolicy,
    QVBoxLayout,
    QWidget,
)

from app_meta import APP_NAME, REPO_URL, detect_version
from config_store import ConfigStore
from dialogs_create_sink import CreateVirtualSinkDialog
from dialogs_patchbay_settings import PatchbaySettingsDialog
from patchbay import launch_patchbay, resolve_patchbay_choice
from rehelp import HelpDialog
from reupdater import UpdateClient, project_from_repo
from resink_backend import ReSinkBackend, SinkInfo, destroy_sink_by_name, set_default_sink
from ui_help_content import help_html
from ui_rows import SinkRow, SinkRowModel


class MainWindow(QMainWindow):
    def __init__(self) -> None:
        super().__init__()

        self.setWindowTitle(f"{APP_NAME} - Virtual Sink Manager")
        self.resize(520, 680)

        self.backend = ReSinkBackend()
        self.store = ConfigStore()
        self.store.ensure_exists()
        # I record my executable path so other apps (like aSyphon) can locate this installed build.
        self.store.record_last_exe_path()

        self._project = project_from_repo(
            REPO_URL,
            version=detect_version(),
            name=APP_NAME,
            settings_org="Retzilience",
            settings_app=APP_NAME,
        )
        self._updater = UpdateClient(self, self._project)

        root = QWidget()
        outer = QVBoxLayout()
        outer.setContentsMargins(10, 10, 10, 10)
        outer.setSpacing(10)
        root.setLayout(outer)
        self.setCentralWidget(root)

        outer.addLayout(self._make_header())

        self.sinks_panel = self._make_panel("Sinks")
        self.sinks_list = self._make_sinks_list()
        self.sinks_panel_layout.addWidget(self.sinks_list, 1)
        outer.addWidget(self.sinks_panel, 1)

        outer.addLayout(self._make_footer_actions())

        self.refresh()

    def _open_help(self) -> None:
        dlg = HelpDialog(
            self,
            self._project,
            html=help_html(self._project.name or self._project.repo),
            updater=self._updater,
        )
        dlg.exec()

    def _make_header(self) -> QHBoxLayout:
        header = QHBoxLayout()
        header.setSpacing(10)

        title = QLabel(APP_NAME)
        title.setObjectName("Title")
        title.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)

        backend = QLabel(self.backend.server_label())
        backend.setObjectName("Subtle")
        backend.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        backend.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)

        help_btn = QPushButton("Help / About")
        help_btn.clicked.connect(self._open_help)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.refresh)

        header.addWidget(title, 2)
        header.addWidget(backend, 3)
        header.addWidget(help_btn, 0)
        header.addWidget(refresh_btn, 0)
        return header

    def _make_panel(self, title: str) -> QFrame:
        frame = QFrame()
        frame.setObjectName("Panel")

        layout = QVBoxLayout()
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        frame.setLayout(layout)

        top = QHBoxLayout()
        top.setSpacing(10)

        t = QLabel(title)
        f = QFont()
        f.setPointSize(12)
        f.setWeight(QFont.DemiBold)
        t.setFont(f)

        self._panel_right = QLabel("")
        self._panel_right.setObjectName("Subtle")
        self._panel_right.setAlignment(Qt.AlignRight | Qt.AlignVCenter)

        top.addWidget(t)
        top.addStretch(1)
        top.addWidget(self._panel_right)
        layout.addLayout(top)

        self.sinks_panel_layout = layout
        return frame

    def _make_sinks_list(self) -> QScrollArea:
        container = QWidget()
        v = QVBoxLayout()
        v.setContentsMargins(0, 0, 0, 0)
        v.setSpacing(10)
        container.setLayout(v)

        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll.setFrameShape(QFrame.NoFrame)
        scroll.setWidget(container)

        scroll.setAlignment(Qt.AlignTop)

        scroll._container = container  # type: ignore[attr-defined]
        scroll._layout = v  # type: ignore[attr-defined]
        return scroll

    def _sinks_layout(self) -> QVBoxLayout:
        return self.sinks_list._layout  # type: ignore[attr-defined]

    def _clear_layout(self, lay: QVBoxLayout) -> None:
        while lay.count():
            item = lay.takeAt(0)
            w = item.widget()
            if w is not None:
                w.setParent(None)
                w.deleteLater()

    def _make_footer_actions(self) -> QHBoxLayout:
        row = QHBoxLayout()
        row.setSpacing(8)

        self.create_btn = QPushButton("Create New Virtual Sink")
        self.create_btn.setObjectName("Primary")
        self.create_btn.clicked.connect(self._create_sink)

        self.destroy_btn = QPushButton("Destroy Selected Sinks")
        self.destroy_btn.setObjectName("Danger")
        self.destroy_btn.clicked.connect(self._destroy_selected)

        self.default_btn = QPushButton("Make Default")
        self.default_btn.setObjectName("Primary")
        self.default_btn.clicked.connect(self._make_default)

        self.open_patch_btn = QPushButton("Open Patchbay")
        self.open_patch_btn.clicked.connect(self._open_patchbay)

        cog_icon = QIcon.fromTheme("preferences-system")
        settings_btn = QPushButton("⚙" if cog_icon.isNull() else "")
        settings_btn.setObjectName("Icon")
        if not cog_icon.isNull():
            settings_btn.setIcon(cog_icon)
        settings_btn.setFixedSize(38, 34)
        settings_btn.clicked.connect(self._patchbay_settings)

        row.addWidget(self.create_btn, 1)
        row.addWidget(self.destroy_btn, 1)
        row.addWidget(self.default_btn, 0)
        row.addWidget(self.open_patch_btn, 0)
        row.addWidget(settings_btn, 0)

        return row

    def _rows(self) -> List[SinkRow]:
        lay = self._sinks_layout()
        out: List[SinkRow] = []
        for i in range(lay.count()):
            w = lay.itemAt(i).widget()
            if isinstance(w, SinkRow):
                out.append(w)
        return out

    def _selected_virtual_sinks(self) -> List[SinkRowModel]:
        out: List[SinkRowModel] = []
        for r in self._rows():
            m = r.model()
            if not m:
                continue
            if m.is_virtual and r.is_selected():
                out.append(m)
        return out

    def _update_action_states(self) -> None:
        sel = self._selected_virtual_sinks()
        n = len(sel)

        total_rows = len(self._rows())
        self._panel_right.setText(f"{total_rows} items • {n} selected")

        self.destroy_btn.setEnabled(n > 0)
        self.default_btn.setEnabled(n == 1)

    def _rebuild_sink_rows(self, sinks: List[SinkInfo]) -> None:
        lay = self._sinks_layout()
        self._clear_layout(lay)

        for s in sinks:
            row = SinkRow()
            row.set_model(
                SinkRowModel(
                    name=s.name,
                    description=s.description,
                    is_virtual=s.is_virtual,
                    is_default=s.is_default,
                )
            )
            row.selection_changed.connect(self._update_action_states)
            lay.addWidget(row)

        self._update_action_states()

    def refresh(self) -> None:
        try:
            sinks = self.backend.list_sinks()
            self._rebuild_sink_rows(sinks)
        except Exception as e:
            QMessageBox.critical(self, "Backend error", str(e))

    def _create_sink(self) -> None:
        dlg = CreateVirtualSinkDialog(self)
        if dlg.exec():
            self.refresh()

    def _destroy_selected(self) -> None:
        sel = self._selected_virtual_sinks()
        if not sel:
            QMessageBox.information(self, "Destroy", "No virtual sinks selected.")
            return

        names = "\n".join(f"• {m.description}  [{m.name}]" for m in sel)
        ok = QMessageBox.question(
            self,
            "Destroy selected",
            f"This will destroy {len(sel)} virtual sink(s):\n\n{names}\n\nContinue?",
        )
        if ok != QMessageBox.StandardButton.Yes:
            return

        errors: List[str] = []
        for m in sel:
            try:
                destroy_sink_by_name(m.name)
            except Exception as e:
                errors.append(f"{m.name}: {e}")

        self.refresh()
        if errors:
            QMessageBox.critical(self, "Destroy issues", "\n".join(errors))

    def _make_default(self) -> None:
        sel = self._selected_virtual_sinks()
        if not sel:
            QMessageBox.information(self, "Make default", "Select one virtual sink to set as default.")
            return
        if len(sel) != 1:
            QMessageBox.warning(self, "Make default", "Select exactly one virtual sink.")
            return

        m = sel[0]
        try:
            set_default_sink(m.name)
        except Exception as e:
            QMessageBox.critical(self, "Make default", str(e))
            return

        self.refresh()

    def _patchbay_settings(self) -> None:
        dlg = PatchbaySettingsDialog(self.store, self)
        dlg.exec()

    def _open_patchbay(self) -> None:
        choice = resolve_patchbay_choice(self.store)
        if choice is None:
            QMessageBox.information(
                self,
                "Patchbay",
                "No patchbay is configured yet. Configure one in Patchbay settings.",
            )
            self._patchbay_settings()
            return

        launch_patchbay(choice, self)
from __future__ import annotations

from dataclasses import dataclass

from PySide6.QtCore import Qt, Signal
from PySide6.QtWidgets import QLabel, QVBoxLayout, QWidget

from widgets import ElideLabel


@dataclass(frozen=True)
class SinkRowModel:
    name: str
    description: str
    is_virtual: bool
    is_default: bool


class SinkRow(QWidget):
    selection_changed = Signal()

    def __init__(self) -> None:
        super().__init__()

        self.setObjectName("RowCard")
        self.setProperty("kind", "physical")
        self.setProperty("selected", False)
        self.setProperty("default", False)

        self._model: SinkRowModel | None = None
        self._selected = False

        self.desc_lbl = ElideLabel()
        self.desc_lbl.setAlignment(Qt.AlignCenter)
        self.desc_lbl.setObjectName("SinkTitle")

        self.kind_pill = QLabel("—")
        self.kind_pill.setObjectName("KindPill")
        self.kind_pill.setAlignment(Qt.AlignCenter)
        self.kind_pill.setProperty("kind", "physical")

        self.name_lbl = ElideLabel()
        self.name_lbl.setAlignment(Qt.AlignCenter)
        self.name_lbl.setObjectName("SinkName")

        self.select_bar = QLabel("")
        self.select_bar.setObjectName("SelectBar")
        self.select_bar.setAlignment(Qt.AlignCenter)
        self.select_bar.setProperty("sel", False)
        self.select_bar.setProperty("kind", "virtual")

        lay = QVBoxLayout()
        lay.setContentsMargins(12, 10, 12, 10)
        lay.setSpacing(8)
        self.setLayout(lay)

        lay.addWidget(self.desc_lbl, 0)
        lay.addWidget(self.kind_pill, 0, Qt.AlignHCenter)
        lay.addWidget(self.name_lbl, 0)
        lay.addWidget(self.select_bar, 0)

        self.setCursor(Qt.ArrowCursor)

    def model(self) -> SinkRowModel | None:
        return self._model

    def is_selected(self) -> bool:
        return bool(self._selected)

    def set_selected(self, v: bool) -> None:
        if self._model is None:
            return
        if not self._model.is_virtual:
            self._selected = False
            self._sync_state()
            return

        self._selected = bool(v)
        self._sync_state()

    def mouseReleaseEvent(self, event) -> None:
        if event.button() == Qt.MouseButton.LeftButton:
            if self._model is not None and self._model.is_virtual:
                self._selected = not self._selected
                self._sync_state()
                self.selection_changed.emit()
                event.accept()
                return
        super().mouseReleaseEvent(event)

    def set_model(self, m: SinkRowModel) -> None:
        self._model = m

        self.desc_lbl.setText(m.description)
        self.name_lbl.setText(m.name)

        kind = "virtual" if m.is_virtual else "physical"
        self.setProperty("kind", kind)
        self.setProperty("default", bool(m.is_default))

        if m.is_virtual:
            self.kind_pill.setText("VIRTUAL")
            self.kind_pill.setProperty("kind", "virtual")
            self.select_bar.setVisible(True)
            self.setCursor(Qt.PointingHandCursor)
        else:
            self.kind_pill.setText("PHYSICAL")
            self.kind_pill.setProperty("kind", "physical")
            self.select_bar.setVisible(False)
            self._selected = False
            self.setCursor(Qt.ArrowCursor)

        self.setToolTip(f"{m.description}\n{m.name}")
        self._sync_state()

    def _sync_state(self) -> None:
        m = self._model
        if m is None:
            return

        if m.is_virtual:
            self.setProperty("selected", bool(self._selected))
            self.select_bar.setProperty("sel", bool(self._selected))
            self.select_bar.setText("Selected" if self._selected else "Not Selected")
        else:
            self.setProperty("selected", False)

        self.style().unpolish(self)
        self.style().polish(self)

        self.kind_pill.style().unpolish(self.kind_pill)
        self.kind_pill.style().polish(self.kind_pill)

        if m.is_virtual:
            self.select_bar.style().unpolish(self.select_bar)
            self.select_bar.style().polish(self.select_bar)

        self.update()
# source/widgets.py
from __future__ import annotations

from PySide6.QtCore import QEasingCurve, Property, QRectF, QSize, Qt, QPropertyAnimation
from PySide6.QtGui import QColor, QFontMetrics, QPainter, QPen
from PySide6.QtWidgets import QAbstractButton, QLabel


class ToggleSwitch(QAbstractButton):
    def __init__(self, parent=None) -> None:
        super().__init__(parent)
        self.setCheckable(True)
        self.setCursor(Qt.PointingHandCursor)

        self._offset = 0.0
        self._anim = QPropertyAnimation(self, b"offset", self)
        self._anim.setDuration(140)
        self._anim.setEasingCurve(QEasingCurve.InOutCubic)

        self._on_bg = QColor("#506eaa")
        self._off_bg = QColor("#2a2a30")
        self._knob = QColor("#f2f2f2")
        self._border = QColor("#2a2a30")

        self.toggled.connect(self._on_toggled)
        self._offset = 1.0 if self.isChecked() else 0.0
        self.setFixedSize(46, 24)

    def sizeHint(self) -> QSize:
        return QSize(46, 24)

    def _on_toggled(self, checked: bool) -> None:
        self._anim.stop()
        self._anim.setStartValue(self._offset)
        self._anim.setEndValue(1.0 if checked else 0.0)
        self._anim.start()

    def get_offset(self) -> float:
        return self._offset

    def set_offset(self, v: float) -> None:
        self._offset = float(v)
        self.update()

    offset = Property(float, get_offset, set_offset)

    def paintEvent(self, _event) -> None:
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing, True)

        r = QRectF(0.5, 0.5, self.width() - 1.0, self.height() - 1.0)
        rad = r.height() / 2.0

        bg = self._on_bg if self.isChecked() else self._off_bg
        p.setPen(QPen(self._border, 1.0))
        p.setBrush(bg)
        p.drawRoundedRect(r, rad, rad)

        m = 3.0
        d = r.height() - 2 * m
        x = r.x() + m + self._offset * (r.width() - 2 * m - d)
        knob = QRectF(x, r.y() + m, d, d)

        p.setPen(Qt.NoPen)
        p.setBrush(self._knob)
        p.drawEllipse(knob)
        p.end()


class StatusPill(QLabel):
    def __init__(self, parent=None) -> None:
        super().__init__(parent)
        self.setAlignment(Qt.AlignCenter)
        self.setFixedWidth(110)
        self.setText("—")
        self.set_state("off")

    def set_state(self, state: str) -> None:
        if state == "on":
            bg, bd, fg = "#23314a", "#3b4f7a", "#d6e2ff"
        elif state == "pending":
            bg, bd, fg = "#3a3424", "#7a6231", "#f3e6c8"
        elif state == "error":
            bg, bd, fg = "#3a2424", "#7a3131", "#f3c8c8"
        else:
            bg, bd, fg = "#2a2a30", "#3a3a42", "#d6d6d6"

        self.setStyleSheet(
            f"""
            QLabel {{
                background: {bg};
                border: 1px solid {bd};
                border-radius: 10px;
                padding: 4px 8px;
                color: {fg};
                font-weight: 600;
            }}
            """
        )

    def setTextAndState(self, text: str, state: str) -> None:
        self.setText(text)
        self.set_state(state)


class ElideLabel(QLabel):
    def __init__(self, parent=None) -> None:
        super().__init__(parent)
        self.setTextInteractionFlags(Qt.TextSelectableByMouse)

    def paintEvent(self, event) -> None:
        fm = QFontMetrics(self.font())
        txt = fm.elidedText(self.text(), Qt.ElideRight, max(10, self.width() - 6))
        old = self.text()
        try:
            self.setText(txt)
            super().paintEvent(event)
        finally:
            self.setText(old)
